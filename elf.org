#+TITLE: A Common Lisp library for manipulating ELF files
#+OPTIONS: num:nil ^:nil
#+STARTUP: hideblocks
#+STYLE: <link rel="stylesheet" href="/~eschulte/stylesheet.css" type="text/css">

* ELF
[[https://github.com/eschulte/elf/blob/master/elf.lisp][elf.lisp]] is a common lisp library for the manipulation of ELF files,
which can be used to read, inspect, modify and write elf files.

See [[https://github.com/eschulte/elf/blob/master/ELF.txt][ELF.txt]] for more information on the elf format.  Much of the code
in =elf.lisp= is a direct translation of the elf data structures
described in the =ELF.txt= document augmented with specific
information translated from file:/usr/include/elf.h.

* Example Usage
  :PROPERTIES:
  :package:  elf
  :END:
** load the elf library
First load the =elf= file, notice that we're loading the testing file
because we'll use some of the inspection functions defined therein
(e.g., =show-it= and =different-it=).
#+begin_src lisp :package cl-user :results silent
  (in-package #:cl-user)
  (load "elf-test.lisp")
  (in-package #:elf)
#+end_src

** create a simple elf binary and confirm it is an elf file
For the remainder of this example, we'll use a simple elf binary
executable named =hello=, compiled from the following C code.
#+begin_src C
  main(){puts("hello world");}
#+end_src
with =gcc -o hello hello.c=.

We can check that this is indeed an elf file by checking the magic
number at the start of the file.
#+begin_src lisp
  (elf-p "hello") ; => T
#+end_src

** read this binary into an elf object, and view it's header information
Then we read the binary file into an elf object (see file:elf.lisp for
information on the fields of the elf class).
#+begin_src lisp :results silent
  (setf elf (read-elf "hello"))
#+end_src

We can inspect the header at the top of the elf file.
#+begin_src lisp :results output
  (show-it (header elf))
#+end_src

** view section-table and program-table information
We can list the names of the sections of the elf file.  See the
section class defined in file:elf.lisp for more information on
sections.
#+begin_src lisp
  (mapcar #'name (sections elf))
  ;; => ("" ".interp" ".note.ABI-tag" ".note.gnu.build-id" ".gnu.hash"...
#+end_src

We can list the segments in the program table, and view both the
layout of the elements of the elf file, both in it's binary file and
when it is an executable image in memory.
#+begin_src lisp :results output
  ;; looking at the program table
  (mapcar #'show-it (program-table elf))
#+end_src

#+begin_src lisp :results output
  ;; view the contents of elf, as they exist in the file
  (show-file-layout elf)
#+end_src

#+begin_src lisp :results output
  ;; view the contents of elf, as they exist in the file
  (show-memory-layout elf)
#+end_src

** write an elf object to disk
We can write out the elf file to disk.
#+begin_src lisp :results silent
  ;; write out the elf file, the results should be identical to the original
  (write-elf elf "hello2")
#+end_src

The resulting file will be identical to the original file from which
the elf object was read.
#+begin_src sh
  diff hello hello2 && echo they are the same
#+end_src

** manipulate the contents of an elf object
We can manipulate these elf objects, and then write the results back
out to disk.  For example we can change the code in the =.text=
section of the file, and then write the results back out to disk.
#+begin_src lisp :results silent
  ;; change the .text section -- this change doesn't break the program
  (setf elf "hello") ; re-read a clean elf from hello
  (aref (data (named-section elf ".text")) 40) ; => 144
  (setf (aref (data (named-section elf ".text")) 40) #xc3) ; => 195
  (aref (data (named-section elf ".text")) 40) ; => 195

  ;; When we write the modified elf to a file, the resulting file will
  ;; be different than the original hello (in one byte) but will still
  ;; execute since we changed a byte off of the execution path
  (write-elf elf "hello2")
#+end_src

Meta information like the relevant program and section headers, as
well as symbol information in the =.dynamic= section of the file will
be automatically updated.
#+begin_src lisp
  (let ((text (named-section elf ".text")))
    (setf (data text)
          (concatenate 'vector
                       (data text)
                       (make-array 16 :initial-element #x90))))
  (write-elf elf "hello3")
#+end_src
Note however that the resulting file will segfault on evaluation,
because even though the meta-data of the elf file is updated
automatically, there are hard-coded offsets and memory locations in
the compiled data contained in the elf file, which can not be
automatically updated.

* License

Copyright (C) 2010 Eric Schulte

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a [[file:COPYING][copy of the GNU General Public License]]
along with this program.  If not, see <http://www.gnu.org/licenses/>.
