           A Common Lisp library for manipulating ELF files
           ================================================


Table of Contents
=================
ELF
Example Usage
    load the elf library
    create a simple elf binary and confirm it is an elf file
    read this binary into an elf object, and view it's header information
    view section-table and program-table information
    write an elf object to disk
    manipulate the contents of an elf object
License


ELF 
====
[elf.lisp] is a common lisp library for the manipulation of ELF files,
which can be used to read, inspect, modify and write elf files.

See [ELF.txt] for more information on the elf format.  Much of the code
in =elf.lisp= is a direct translation of the elf data structures
described in the =ELF.txt= document augmented with specific
information translated from [file:/usr/include/elf.h].


[elf.lisp]: https://github.com/eschulte/elf/blob/master/elf.lisp
[ELF.txt]: https://github.com/eschulte/elf/blob/master/ELF.txt

Example Usage 
==============

load the elf library 
---------------------
First load the =elf= file, notice that we're loading the testing file
because we'll use some of the inspection functions defined therein
(e.g., =show-it= and =different-it=).


  (in-package #:cl-user)
  (load "elf-test.lisp")
  (in-package #:elf)


create a simple elf binary and confirm it is an elf file 
---------------------------------------------------------
For the remainder of this example, we'll use a simple elf binary
executable named =hello=, compiled from the following C code.


  main(){puts("hello world");}

with =gcc -o hello hello.c=.

We can check that this is indeed an elf file by checking the magic
number at the start of the file.


  (elf-p "hello") ; => T


read this binary into an elf object, and view it's header information 
----------------------------------------------------------------------
Then we read the binary file into an elf object (see [file:elf.lisp] for
information on the fields of the elf class).


  (setf elf (read-elf "hello"))


We can inspect the header at the top of the elf file.


  (show-it (header elf))


view section-table and program-table information 
-------------------------------------------------
We can list the names of the sections of the elf file.  See the
section class defined in [file:elf.lisp] for more information on
sections.


  (mapcar #'name (sections elf))
  ;; => ("" ".interp" ".note.ABI-tag" ".note.gnu.build-id" ".gnu.hash"...


We can list the segments in the program table, and view both the
layout of the elements of the elf file, both in it's binary file and
when it is an executable image in memory.


  ;; looking at the program table
  (mapcar #'show-it (program-table elf))




  ;; view the contents of elf, as they exist in the file
  (show-file-layout elf)




  ;; view the contents of elf, as they exist in the file
  (show-memory-layout elf)


write an elf object to disk 
----------------------------
We can write out the elf file to disk.


  ;; write out the elf file, the results should be identical to the original
  (write-elf elf "hello2")


The resulting file will be identical to the original file from which
the elf object was read.


  diff hello hello2 && echo they are the same


manipulate the contents of an elf object 
-----------------------------------------
We can manipulate these elf objects, and then write the results back
out to disk.  For example we can change the code in the =.text=
section of the file, and then write the results back out to disk.


  ;; change the .text section -- this change doesn't break the program
  (setf elf "hello") ; re-read a clean elf from hello
  (aref (data (named-section elf ".text")) 40) ; => 144
  (setf (aref (data (named-section elf ".text")) 40) #xc3) ; => 195
  (aref (data (named-section elf ".text")) 40) ; => 195
  
  ;; When we write the modified elf to a file, the resulting file will
  ;; be different than the original hello (in one byte) but will still
  ;; execute since we changed a byte off of the execution path
  (write-elf elf "hello2")


Meta information like the relevant program and section headers, as
well as symbol information in the =.dynamic= section of the file will
be automatically updated.


  (let ((text (named-section elf ".text")))
    (setf (data text)
          (concatenate 'vector
                       (data text)
                       (make-array 16 :initial-element #x90))))
  (write-elf elf "hello3")

Note however that the resulting file will segfault on evaluation,
because even though the meta-data of the elf file is updated
automatically, there are hard-coded offsets and memory locations in
the compiled data contained in the elf file, which can not be
automatically updated.

License 
========

Copyright (C) 2010 Eric Schulte

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a [copy of the GNU General Public License]
along with this program.  If not, see [http://www.gnu.org/licenses/].

[copy of the GNU General Public License]: file:COPYING

